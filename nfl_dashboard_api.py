"""
FastAPI backend to serve NFL score predictions and model metrics.

This module exposes two API endpoints:

* ``/api/predict`` – Accepts ``season`` and ``week`` query parameters and
  returns a list of predicted scores, spreads, and totals for each scheduled
  game in that week. The predictions are generated by training a suite of
  regression models on all historical games prior to the requested week and
  selecting the model with the lowest combined RMSE.

* ``/api/metrics`` – Returns cross‑validated performance metrics for each
  candidate model. This helps users understand how different algorithms
  compare on the available data.

The root path ``/`` serves a static HTML dashboard. This file must exist in
the same directory as this script under the name ``nfl_dashboard.html``. If
``nfl_data_py`` is unavailable at runtime, the API returns mock data to
maintain functionality during development or in restricted environments.
"""

from __future__ import annotations

import os
from typing import List, Dict, Any

from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import numpy as np
import pandas as pd

try:
    print("API is starting, attempting to import modelling libraries...")
    from nfl_score_prediction import (
        load_game_data,
        compute_team_statistics,
        prepare_model_data,
        evaluate_models,
        train_final_model,
    )
    import nfl_data_py as nfl
    HAS_NFL_DATA = True
    print("--> SUCCESS: All modelling libraries imported correctly.")
except Exception as e:
    HAS_NFL_DATA = False
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print("!!! CRITICAL ERROR: FAILED to import modelling libraries.     !!!")
    print("!!! The API will only serve sample data. See error below.   !!!")
    print(f"!!! Error details: {e}")
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")


app = FastAPI(title="NFL Score Prediction API")

# Allow cross‑origin requests so that the dashboard can be served from a
# different domain or file system.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class Prediction(BaseModel):
    season: int
    week: int
    home_team: str
    away_team: str
    home_pred: float
    away_pred: float
    pred_spread: float
    pred_total: float
    spread_line: float | None = None
    total_line: float | None = None


class ModelMetric(BaseModel):
    model: str
    MAE_total: float
    RMSE_total: float
    R2_home: float
    R2_away: float


def _generate_predictions_for_week(season: int, week: int) -> List[Dict[str, Any]]:
    """Generate predictions for a specific season and week using the best model."""
    games_full = load_game_data(2015, season, include_unplayed=True)
    games_with_stats = compute_team_statistics(games_full)
    X_full, Y_full = prepare_model_data(games_with_stats)
    train_mask = (
        games_with_stats['home_score'].notna() &
        (
            (games_with_stats['season'] < season) |
            ((games_with_stats['season'] == season) & (games_with_stats['week'] < week))
        )
    )
    pred_mask = (
        (games_with_stats['season'] == season) &
        (games_with_stats['week'] == week)
    )
    X_train = X_full.loc[train_mask].reset_index(drop=True)
    Y_train = Y_full.loc[train_mask].reset_index(drop=True)
    X_pred = X_full.loc[pred_mask]
    if len(X_train) > 0:
        means = X_train.mean()
        X_train = X_train.fillna(means)
        X_pred = X_pred.fillna(means)
    else:
        X_train = X_train.fillna(0)
        X_pred = X_pred.fillna(0)
    if len(X_train) > 0:
        metrics = evaluate_models(X_train, Y_train)
        best_model_name = metrics.sort_values('RMSE_total').iloc[0]['model']
    else:
        # Fallback if no training data exists (e.g., predicting week 1 of first season)
        best_model_name = 'ElasticNet'
    model = train_final_model(X_train, Y_train, model_name=str(best_model_name))
    preds = model.predict(X_pred)
    upcoming_games = games_with_stats.loc[pred_mask, [
        'season', 'week', 'home_team', 'away_team', 'spread_line', 'total_line'
    ]].copy()
    upcoming_games['home_pred'] = preds[:, 0]
    upcoming_games['away_pred'] = preds[:, 1]
    upcoming_games['pred_spread'] = upcoming_games['home_pred'] - upcoming_games['away_pred']
    upcoming_games['pred_total'] = upcoming_games['home_pred'] + upcoming_games['away_pred']
    if 'spread_line' not in upcoming_games.columns:
        upcoming_games['spread_line'] = np.nan
    if 'total_line' not in upcoming_games.columns:
        upcoming_games['total_line'] = np.nan
    return upcoming_games.to_dict(orient='records')


def _get_model_metrics() -> List[Dict[str, Any]]:
    """Compute cross‑validated model metrics on the most recent completed season."""
    try:
        max_season = 2025
        games_full = load_game_data(2015, max_season, include_unplayed=False)
        games_with_stats = compute_team_statistics(games_full)
        X, Y = prepare_model_data(games_with_stats)
        metrics = evaluate_models(X, Y)
        return metrics.to_dict(orient='records')
    except Exception:
        return []


@app.get("/api/predict", response_model=List[Prediction])
def api_predict(season: int, week: int) -> List[Prediction]:
    """API endpoint to generate predictions for a given season and week."""
    if not HAS_NFL_DATA:
        sample = [
            {
                "season": 2025, "week": 1, "home_team": "KC", "away_team": "BAL",
                "home_pred": 27.5, "away_pred": 24.1,
                "pred_spread": 3.4, "pred_total": 51.6,
                "spread_line": -3.0, "total_line": 52.0
            },
            {
                "season": 2025, "week": 1, "home_team": "PHI", "away_team": "GB",
                "home_pred": 26.2, "away_pred": 23.8,
                "pred_spread": 2.4, "pred_total": 50.0,
                "spread_line": -1.5, "total_line": 48.5
            }
        ]
        return sample
    try:
        return _generate_predictions_for_week(season, week)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/metrics", response_model=List[ModelMetric])
def api_metrics() -> List[ModelMetric]:
    """API endpoint to retrieve model performance metrics."""
    if not HAS_NFL_DATA:
        sample = [
            {"model": "StackingEnsemble", "MAE_total": 15.82, "RMSE_total": 20.11, "R2_home": 0.25, "R2_away": 0.23},
            {"model": "XGBoost", "MAE_total": 15.91, "RMSE_total": 20.25, "R2_home": 0.24, "R2_away": 0.22},
            {"model": "LightGBM", "MAE_total": 15.95, "RMSE_total": 20.30, "R2_home": 0.24, "R2_away": 0.22},
            {"model": "GradientBoosting", "MAE_total": 16.10, "RMSE_total": 20.55, "R2_home": 0.22, "R2_away": 0.20},
            {"model": "RandomForest", "MAE_total": 16.25, "RMSE_total": 20.78, "R2_home": 0.20, "R2_away": 0.18},
            {"model": "LinearRegression", "MAE_total": 17.50, "RMSE_total": 22.10, "R2_home": 0.15, "R2_away": 0.14},
        ]
        return sample
    try:
        return _get_model_metrics()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/", response_class=HTMLResponse)
def serve_dashboard() -> HTMLResponse:
    """Serve the interactive dashboard HTML file."""
    file_path = os.path.join(os.path.dirname(__file__), "nfl_dashboard.html")
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Dashboard HTML not found")
    return FileResponse(file_path, media_type="text/html")
